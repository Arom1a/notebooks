---
date: 2025-09-18
---
## 1 Merge sort

```sml
(* msort:    int list -> inst list
 * REQUIRES: true
 * ENSURES:  msort(L) evaluates to a sorted permutation of L. 
 *) 
fun msort ([] : int list) : int list = []
  | msort [x] = [x]
  | msort L = 
        let
            val (A, B) = split L
        in
            merge (msort A, msort B)
        end
```

helper functions:

```sml
(* split:    int list -> int list * int list
 * REQUIRES: true
 * ENSURES:  split(L) evaluates to a pair of list (A, B) such that length(A) and length (B) differ by at most 1, and A@B is a permutation of L. 
 *)
fun split ([] : int list) : int list * int list = ([], [])
  | split [x] = ([x], [])
  | split (x::y::L) = 
        let
            val (A, B) = split L
        in
            (x::A, y::B)
        end

(* merge:    int list * int list -> int list
 * REQUIRES: A and B are sorted lists. 
 * ENSURES:  merge (A, B) evalutes to a sorted permutation of A@B. 
 *)
fun merge ([] : int list, B : int list) : int list = B
  | merge (A, []) = A
  | merge (x::A, y::B) = (
        case compare (x, y) of
            LESS => x :: merge (A, y::B)
          | EQUAL => x::y::merge(A, B)
          | GREATER => y :: merge(x::A, B)
    )
```